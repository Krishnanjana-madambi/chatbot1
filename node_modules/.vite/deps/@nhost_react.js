import {
  Ar,
  Be,
  E,
  F,
  Fe,
  G,
  InterpreterStatus,
  Ir,
  J2 as J,
  Je,
  K2 as K,
  Qe,
  S,
  Sr,
  State,
  Xe,
  Y2 as Y,
  Ye,
  Ze,
  ar,
  cr,
  dr,
  er,
  fr,
  hr,
  interpret,
  ir,
  je,
  jwtDecode,
  kr,
  lr,
  nr,
  or,
  re,
  rr,
  se,
  sr,
  te,
  toObserver,
  tr,
  ur,
  x,
  ze
} from "./chunk-I7P4NATA.js";
import "./chunk-U2PSID6I.js";
import {
  require_react
} from "./chunk-LXGCQ6UQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is(x3, y2) {
        return x3 === y2 && (0 !== x3 || 1 / x3 === 1 / y2) || x3 !== x3 && y2 !== y2;
      }
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React3.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState2({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect2(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect3(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React3 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState2 = React3.useState, useEffect3 = React3.useEffect, useLayoutEffect2 = React3.useLayoutEffect, useDebugValue = React3.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React3.useSyncExternalStore ? React3.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is(x3, y2) {
        return x3 === y2 && (0 !== x3 || 1 / x3 === 1 / y2) || x3 !== x3 && y2 !== y2;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React3 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef4 = React3.useRef, useEffect3 = React3.useEffect, useMemo = React3.useMemo, useDebugValue = React3.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef4(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else
          inst = instRef.current;
        instRef = useMemo(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect3(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/@nhost/react/dist/index.esm.js
var import_react6 = __toESM(require_react());

// node_modules/@xstate/react/es/useMachine.js
var import_react3 = __toESM(require_react());
var import_with_selector = __toESM(require_with_selector());

// node_modules/@xstate/react/es/useInterpret.js
var import_react2 = __toESM(require_react());

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react = __toESM(require_react());
var index = import_react.useLayoutEffect;

// node_modules/@xstate/react/es/useConstant.js
var React = __toESM(require_react());
function useConstant(fn) {
  var ref = React.useRef();
  if (!ref.current) {
    ref.current = { v: fn() };
  }
  return ref.current.v;
}

// node_modules/@xstate/react/es/useInterpret.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar2;
};
function useIdleInterpreter(getMachine, options) {
  var machine = useConstant(function() {
    return typeof getMachine === "function" ? getMachine() : getMachine;
  });
  if (typeof getMachine !== "function") {
    var _a = __read((0, import_react2.useState)(machine), 1), initialMachine = _a[0];
    if (getMachine !== initialMachine) {
      console.warn("Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\nPlease make sure that you pass the same Machine as argument each time.");
    }
  }
  var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, ["context", "guards", "actions", "activities", "services", "delays", "state"]);
  var service = useConstant(function() {
    var machineConfig = {
      context,
      guards,
      actions,
      activities,
      services,
      delays
    };
    var machineWithConfig = machine.withConfig(machineConfig, function() {
      return __assign(__assign({}, machine.context), context);
    });
    return interpret(machineWithConfig, interpreterOptions);
  });
  index(function() {
    Object.assign(service.machine.options.actions, actions);
    Object.assign(service.machine.options.guards, guards);
    Object.assign(service.machine.options.activities, activities);
    Object.assign(service.machine.options.services, services);
    Object.assign(service.machine.options.delays, delays);
  }, [actions, guards, activities, services, delays]);
  return service;
}
function useInterpret(getMachine) {
  var _a = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    _a[_i - 1] = arguments[_i];
  }
  var _b = __read(_a, 2), _c = _b[0], options = _c === void 0 ? {} : _c, observerOrListener = _b[1];
  var service = useIdleInterpreter(getMachine, options);
  (0, import_react2.useEffect)(function() {
    if (!observerOrListener) {
      return;
    }
    var sub = service.subscribe(toObserver(observerOrListener));
    return function() {
      sub.unsubscribe();
    };
  }, [observerOrListener]);
  (0, import_react2.useEffect)(function() {
    var rehydratedState = options.state;
    service.start(rehydratedState ? State.create(rehydratedState) : void 0);
    return function() {
      service.stop();
      service.status = InterpreterStatus.NotStarted;
    };
  }, []);
  return service;
}

// node_modules/@xstate/react/es/utils.js
function getServiceSnapshot(service) {
  return service.status !== 0 ? service.getSnapshot() : service.machine.initialState;
}
function isService(actor) {
  return "state" in actor && "machine" in actor;
}

// node_modules/@xstate/react/es/useActor.js
var import_react4 = __toESM(require_react());
var import_with_selector2 = __toESM(require_with_selector());
function isActorWithState(actorRef) {
  return "state" in actorRef;
}

// node_modules/@xstate/react/es/useSelector.js
var import_react5 = __toESM(require_react());
var import_with_selector3 = __toESM(require_with_selector());
var defaultCompare = function(a, b) {
  return a === b;
};
var defaultGetSnapshot = function(a, initialStateCacheRef) {
  if (isService(a)) {
    if (a.status === 0 && initialStateCacheRef.current) {
      return initialStateCacheRef.current;
    }
    var snapshot = getServiceSnapshot(a);
    initialStateCacheRef.current = a.status === 0 ? snapshot : null;
    return snapshot;
  }
  return isActorWithState(a) ? a.state : void 0;
};
function useSelector(actor, selector, compare, getSnapshot) {
  if (compare === void 0) {
    compare = defaultCompare;
  }
  var initialStateCacheRef = (0, import_react5.useRef)(null);
  var subscribe = (0, import_react5.useCallback)(function(handleStoreChange) {
    var unsubscribe = actor.subscribe(handleStoreChange).unsubscribe;
    return unsubscribe;
  }, [actor]);
  var boundGetSnapshot = (0, import_react5.useCallback)(function() {
    if (getSnapshot) {
      return getSnapshot(actor);
    }
    return defaultGetSnapshot(actor, initialStateCacheRef);
  }, [actor, getSnapshot]);
  var selectedSnapshot = (0, import_with_selector3.useSyncExternalStoreWithSelector)(subscribe, boundGetSnapshot, boundGetSnapshot, selector, compare);
  return selectedSnapshot;
}

// node_modules/@xstate/react/es/createActorContext.js
var React2 = __toESM(require_react());

// node_modules/@nhost/react/dist/index.esm.js
var ve = E;
var we = class extends ve {
  constructor(t) {
    super({ ...t, start: false });
  }
};
var I = (0, import_react6.createContext)({});
var xe = ({
  nhost: e,
  initial: t,
  ...r
}) => {
  const i = useInterpret(e.auth.client.machine, { devTools: e.devTools });
  e.auth.client.start({ interpreter: i, initialSession: t, devTools: e.devTools });
  const d = (0, import_react6.useRef)(true);
  return (0, import_react6.useEffect)(() => {
    d.current ? d.current = false : t && i.send("SESSION_UPDATE", { data: { session: t } });
  }, [t, i]), import_react6.default.createElement(I.Provider, { value: e }, r.children);
};
var Ae = xe;
var p = () => {
  var r;
  const t = (r = (0, import_react6.useContext)(I).auth) == null ? void 0 : r.client.interpreter;
  if (!t)
    throw Error("Could not find the Nhost auth client. Did you wrap your app in <NhostProvider />?");
  return t;
};
var A = () => {
  const e = p();
  return useSelector(
    e,
    (t) => ({
      isAuthenticated: t.matches({ authentication: "signedIn" }),
      isLoading: t.hasTag("loading"),
      error: t.context.errors.authentication || null,
      isError: t.matches({ authentication: { signedOut: "failed" } }),
      connectionAttempts: t.context.importTokenAttempts
    }),
    (t, r) => t.isAuthenticated === r.isAuthenticated && t.isLoading === r.isLoading && t.connectionAttempts === r.connectionAttempts
  );
};
function Ue({ children: e }) {
  const { isAuthenticated: t } = A();
  return t ? (0, import_react6.createElement)(import_react6.Fragment, null, e) : null;
}
function Le({ children: e }) {
  const { isAuthenticated: t } = A();
  return t ? null : (0, import_react6.createElement)(import_react6.Fragment, null, e);
}
var U = () => {
  const e = p();
  return useSelector(e, (t) => t.context.accessToken.value);
};
var v = () => (0, import_react6.useContext)(I);
var Ce = () => {
  const e = v(), [t, r] = (0, import_react6.useState)(null), i = !t, d = !!t, [l, h] = (0, import_react6.useState)(false);
  return { add: async (a) => {
    h(true);
    const s = await ze(e.auth.client, a), { error: o } = s;
    return o && r(o), h(false), s;
  }, isLoading: l, isSuccess: i, isError: d, error: t };
};
var Me = () => {
  const e = p(), [t, r] = (0, import_react6.useState)(
    !!e.status && e.getSnapshot().matches({ authentication: "signedIn" })
  );
  return (0, import_react6.useEffect)(() => e.subscribe((d) => {
    const l = d.matches({ authentication: "signedIn" });
    r(l);
  }).unsubscribe, [e]), t;
};
function Ne(e) {
  const t = v(), r = (0, import_react6.useMemo)(() => Ye(t.auth.client), [t]), i = useInterpret(r), d = useSelector(i, (s) => s.matches("requesting")), l = useSelector(i, (s) => s.context.error), h = useSelector(i, (s) => s.matches("idle.error")), m = useSelector(i, (s) => s.matches("idle.success"));
  return { changeEmail: (0, import_react6.useCallback)(
    async (s, o = e) => Qe(i, s, o),
    [i, e]
  ), isLoading: d, needsEmailVerification: m, isError: h, error: l };
}
var Re = () => {
  const e = v(), t = (0, import_react6.useMemo)(() => je(e.auth.client), [e]), r = useInterpret(t), i = useSelector(r, (a) => a.matches({ idle: "error" })), d = useSelector(r, (a) => a.matches({ idle: "success" })), l = useSelector(r, (a) => a.context.error), h = useSelector(r, (a) => a.matches("requesting"));
  return { changePassword: (a) => Xe(r, a), isLoading: h, isSuccess: d, isError: i, error: l };
};
var Ke = () => {
  const e = v(), t = (0, import_react6.useMemo)(() => kr(e.auth.client), [e]), r = useInterpret(t), i = useSelector(
    r,
    (f) => f.matches({ idle: "error" }) || f.matches({ generated: { idle: "error" } })
  ), d = useSelector(r, (f) => f.matches("generating")), l = useSelector(r, (f) => f.matches("generated")), h = useSelector(r, (f) => f.matches({ generated: "activating" })), m = useSelector(r, (f) => f.matches({ generated: "activated" })), a = useSelector(r, (f) => f.matches("disabling")), s = useSelector(r, (f) => f.context.error), o = useSelector(r, (f) => f.context.imageUrl || ""), c = useSelector(r, (f) => f.context.secret || "");
  return {
    generateQrCode: () => Ir(r),
    isGenerating: d,
    qrCodeDataUrl: o,
    isGenerated: l,
    activateMfa: (f) => Sr(r, f),
    isActivating: h,
    isActivated: m,
    isDisabling: a,
    isError: i,
    error: s,
    disableMfa: (f) => Ar(r, f),
    totpSecret: c
  };
};
var Se = () => {
  const e = U();
  return e ? jwtDecode(e) : null;
};
var Pe = (e) => {
  const t = v(), r = (g) => {
    e.send({
      type: "ADD",
      file: g.file,
      bucketId: g.bucketId || E2
    });
  }, i = (g) => J(
    {
      url: t.storage.url,
      accessToken: t.auth.getAccessToken(),
      adminSecret: t.adminSecret,
      ...g
    },
    e
  ), d = () => {
    e.send("CANCEL");
  }, l = () => {
    e.send("DESTROY");
  }, h = useSelector(e, (g) => g.matches("uploading")), m = useSelector(e, (g) => g.matches("uploaded")), a = useSelector(e, (g) => g.matches("error")), s = useSelector(e, (g) => g.context.error || null), o = useSelector(e, (g) => g.context.progress), c = useSelector(e, (g) => g.context.id), E2 = useSelector(e, (g) => g.context.bucketId), u = useSelector(e, (g) => {
    var f;
    return (f = g.context.file) == null ? void 0 : f.name;
  });
  return {
    add: r,
    upload: i,
    cancel: d,
    destroy: l,
    isUploaded: m,
    isUploading: h,
    isError: a,
    error: s,
    progress: o,
    id: c,
    bucketId: E2,
    name: u
  };
};
var Ve = () => {
  const e = useInterpret(G);
  return Pe(e);
};
var L = () => {
  const e = Se();
  return (e == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
};
var De = (e) => {
  const t = L();
  return (t == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
};
var Fe2 = () => {
  const e = v(), [t, r] = (0, import_react6.useState)([]), i = useInterpret(Y, {}, (u) => {
    u.event.type === "UPLOAD_ERROR" ? r(u.context.files.filter((g) => {
      var f;
      return (f = g.getSnapshot()) == null ? void 0 : f.context.error;
    })) : (u.matches("uploaded") || u.event.type === "CLEAR") && t.length > 0 && r([]);
  }), d = (u) => {
    i.send({ type: "ADD", ...u });
  }, l = (u) => K(
    {
      url: e.storage.url,
      accessToken: e.auth.getAccessToken(),
      adminSecret: e.adminSecret,
      ...u
    },
    i
  ), h = () => {
    i.send("CANCEL");
  }, m = () => {
    i.send("CLEAR");
  }, a = useSelector(i, (u) => u.matches("uploading")), s = useSelector(i, (u) => u.matches("uploaded")), o = useSelector(i, (u) => u.matches("error")), c = useSelector(i, (u) => u.context.progress), E2 = useSelector(i, (u) => u.context.files);
  return {
    upload: l,
    add: d,
    clear: m,
    cancel: h,
    progress: c,
    isUploaded: s,
    isUploading: a,
    files: E2,
    isError: o,
    errors: t
  };
};
var _e = (e) => {
  const [t, r] = (0, import_react6.useState)(true), i = U();
  (0, import_react6.useEffect)(() => {
    r(false);
  }, []);
  const d = (0, import_react6.useContext)(I);
  return new Proxy({}, {
    get(l, h) {
      let m = `${d.auth.client.backendUrl}/signin/provider/${h}`;
      const a = e != null && e.connect ? { connect: i } : {};
      return F(
        m,
        S(t ? void 0 : d.auth.client.clientUrl, {
          ...e,
          ...a
        })
      );
    }
  });
};
var qe = (e) => {
  const t = v(), r = (0, import_react6.useMemo)(() => Fe(t.auth.client), [t]), i = useInterpret(r), d = useSelector(i, (s) => s.matches("requesting")), l = useSelector(i, (s) => s.context.error), h = useSelector(i, (s) => s.matches("idle.error")), m = useSelector(i, (s) => s.matches("idle.success"));
  return { resetPassword: (s, o = e) => Ze(i, s, o), isLoading: d, isSent: m, isError: h, error: l };
};
var He = (e) => {
  const t = v(), r = (0, import_react6.useMemo)(() => Be(t.auth.client), [t]), i = useInterpret(r), d = useSelector(i, (s) => s.matches({ idle: "error" })), l = useSelector(i, (s) => s.matches({ idle: "success" })), h = useSelector(i, (s) => s.context.error), m = useSelector(i, (s) => s.matches("requesting"));
  return { sendEmail: (s, o = e) => Je(i, s, o), isLoading: m, isSent: l, isError: d, error: h };
};
var Qe2 = () => {
  const e = p(), t = () => er(e), r = useSelector(
    e,
    (a) => a.context.errors.authentication || null,
    (a, s) => (a == null ? void 0 : a.error) === (s == null ? void 0 : s.error)
  ), i = useSelector(
    e,
    (a) => a.matches({ authentication: { authenticating: "anonymous" } })
  ), d = useSelector(
    e,
    (a) => a.matches({
      authentication: "signedIn"
    })
  ), l = useSelector(
    e,
    (a) => a.matches({ authentication: { signedOut: "failed" } })
  ), h = useSelector(
    e,
    (a) => a.context.user,
    (a, s) => (a == null ? void 0 : a.id) === (s == null ? void 0 : s.id)
  );
  return { accessToken: useSelector(e, (a) => a.context.accessToken.value), error: r, isError: l, isLoading: i, isSuccess: d, signInAnonymous: t, user: h };
};
var $e = () => {
  const e = p(), t = (u, g) => rr(e, u, g), r = (u) => tr(e, u), i = useSelector(
    e,
    (u) => u.context.user,
    (u, g) => (u == null ? void 0 : u.id) === (g == null ? void 0 : g.id)
  ), d = useSelector(e, (u) => u.context.accessToken.value), l = useSelector(e, (u) => u.context.refreshToken.value), h = useSelector(
    e,
    (u) => u.context.errors.authentication || null,
    (u, g) => (u == null ? void 0 : u.error) === (g == null ? void 0 : g.error)
  ), m = useSelector(
    e,
    (u) => u.matches({
      authentication: "signedIn"
    })
  ), a = useSelector(
    e,
    (u) => u.matches({ authentication: { authenticating: "password" } }),
    (u, g) => u === g
  ), s = useSelector(
    e,
    (u) => u.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (u, g) => u === g
  ), o = useSelector(e, (u) => u.context.mfa !== null), c = useSelector(
    e,
    (u) => u.matches({ authentication: { signedOut: "failed" } }),
    (u, g) => u === g
  ), E2 = useSelector(e, (u) => u.context.mfa);
  return {
    accessToken: d,
    refreshToken: l,
    error: h,
    isError: c,
    isLoading: a,
    isSuccess: m,
    needsEmailVerification: s,
    needsMfaOtp: o,
    mfa: E2,
    sendMfaOtp: r,
    signInEmailPassword: t,
    user: i
  };
};
function je2(e) {
  const t = p(), r = (m, a = e) => re(t, m, a), i = useSelector(
    t,
    (m) => m.context.errors.registration || null,
    (m, a) => (m == null ? void 0 : m.error) === (a == null ? void 0 : a.error)
  ), d = useSelector(t, (m) => m.matches("registration.passwordlessEmail")), l = useSelector(
    t,
    (m) => m.matches("registration.incomplete.needsEmailVerification")
  ), h = useSelector(t, (m) => m.matches("registration.incomplete.failed"));
  return { signInEmailPasswordless: r, isLoading: d, isSuccess: l, isError: h, error: i };
}
var Ge = () => {
  const e = p(), t = (o) => nr(e, o), r = useSelector(
    e,
    (o) => o.context.user,
    (o, c) => (o == null ? void 0 : o.id) === (c == null ? void 0 : c.id)
  ), i = useSelector(e, (o) => o.context.accessToken.value), d = useSelector(e, (o) => o.context.refreshToken.value), l = useSelector(
    e,
    (o) => o.context.errors.authentication || null,
    (o, c) => (o == null ? void 0 : o.error) === (c == null ? void 0 : c.error)
  ), h = useSelector(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), m = useSelector(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, c) => o === c
  ), a = useSelector(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, c) => o === c
  ), s = useSelector(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, c) => o === c
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: s,
    isLoading: m,
    isSuccess: h,
    needsEmailVerification: a,
    signInEmailSecurityKey: t,
    user: r
  };
};
var Te = () => {
  const e = p();
  return useSelector(
    e,
    (t) => t.context.user,
    (t, r) => (t && JSON.stringify(t)) === (r && JSON.stringify(r))
  );
};
var Je2 = () => {
  const e = Te(), t = v(), r = L(), i = e ? (r == null ? void 0 : r["x-hasura-auth-elevated"]) === (e == null ? void 0 : e.id) : false, [d, l] = (0, import_react6.useState)(!!i), h = (m) => sr(t.auth.client, m);
  return (0, import_react6.useEffect)(() => {
    l(!!i);
  }, [i]), {
    elevated: d,
    elevateEmailSecurityKey: h
  };
};
var Ye2 = () => {
  const e = p(), t = (s) => ir(e, s), r = useSelector(
    e,
    (s) => s.context.user,
    (s, o) => (s == null ? void 0 : s.id) === (o == null ? void 0 : o.id)
  ), i = useSelector(e, (s) => s.context.accessToken.value), d = useSelector(e, (s) => s.context.refreshToken.value), l = useSelector(
    e,
    (s) => s.context.errors.authentication || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), h = useSelector(e, (s) => s.matches({ authentication: "signedIn" })), m = useSelector(
    e,
    (s) => s.matches({ authentication: { authenticating: "password" } }),
    (s, o) => s === o
  ), a = useSelector(
    e,
    (s) => s.matches({ authentication: { signedOut: "failed" } }),
    (s, o) => s === o
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: a,
    isLoading: m,
    isSuccess: h,
    signInPAT: t,
    user: r
  };
};
function We(e) {
  const t = p(), [r, i] = (0, import_react6.useState)(""), d = (c, E2 = e) => (i(c), se(t, c, E2)), l = async (...c) => {
    if (c.length === 2) {
      const [u, g] = c;
      return or(t, u, g);
    }
    const [E2] = c;
    return or(t, r, E2);
  }, h = useSelector(
    t,
    (c) => c.context.errors.registration || null,
    (c, E2) => (c == null ? void 0 : c.error) === (E2 == null ? void 0 : E2.error)
  ), m = useSelector(
    t,
    (c) => c.matches("registration.passwordlessSms") || c.matches("registration.passwordlessSmsOtp")
  ), a = useSelector(t, (c) => c.matches("authentication.signedIn")), s = useSelector(
    t,
    (c) => c.matches("registration.incomplete.needsOtp")
  ), o = useSelector(t, (c) => c.matches("registration.incomplete.failed"));
  return { signInSmsPasswordless: d, sendOtp: l, isLoading: m, isSuccess: a, needsOtp: s, isError: o, error: h };
}
var ze2 = (e = false) => {
  const t = p(), r = (l) => ar(t, typeof l == "boolean" ? l : e), i = useSelector(
    t,
    (l) => l.matches({ authentication: { signedOut: "success" } }),
    (l, h) => l === h
  ), d = useSelector(
    t,
    (l) => l.context.errors.signout || null,
    (l, h) => (l == null ? void 0 : l.error) === (h == null ? void 0 : h.error)
  );
  return { signOut: r, isSuccess: i, error: d };
};
var Be2 = (e) => {
  const t = p(), r = useSelector(t, (c) => !!c.context.errors.registration), i = useSelector(
    t,
    (c) => c.context.errors.registration || null,
    (c, E2) => (c == null ? void 0 : c.error) === (E2 == null ? void 0 : E2.error)
  ), d = useSelector(t, (c) => c.matches("registration.emailPassword")), l = useSelector(
    t,
    (c) => c.matches("registration.incomplete.needsEmailVerification")
  ), h = useSelector(
    t,
    (c) => c.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), m = (c, E2, u = e, g) => te(t, c, E2, u, g), a = useSelector(
    t,
    (c) => c.context.user,
    (c, E2) => (c == null ? void 0 : c.id) === (E2 == null ? void 0 : E2.id)
  ), s = useSelector(t, (c) => c.context.accessToken.value), o = useSelector(t, (c) => c.context.refreshToken.value);
  return {
    accessToken: s,
    refreshToken: o,
    error: i,
    isError: r,
    isLoading: d,
    isSuccess: h,
    needsEmailVerification: l,
    signUpEmailPassword: m,
    user: a
  };
};
var Xe2 = (e) => {
  const t = p(), r = useSelector(t, (c) => !!c.context.errors.registration), i = useSelector(
    t,
    (c) => c.context.errors.registration || null,
    (c, E2) => (c == null ? void 0 : c.error) === (E2 == null ? void 0 : E2.error)
  ), d = useSelector(t, (c) => c.matches("registration.securityKey")), l = useSelector(
    t,
    (c) => c.matches("registration.incomplete.needsEmailVerification")
  ), h = useSelector(
    t,
    (c) => c.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), m = (c, E2 = e, u) => cr(t, c, E2, u), a = useSelector(
    t,
    (c) => c.context.user,
    (c, E2) => (c == null ? void 0 : c.id) === (E2 == null ? void 0 : E2.id)
  ), s = useSelector(t, (c) => c.context.accessToken.value), o = useSelector(t, (c) => c.context.refreshToken.value);
  return {
    accessToken: s,
    refreshToken: o,
    error: i,
    isError: r,
    isLoading: d,
    isSuccess: h,
    needsEmailVerification: l,
    signUpEmailSecurityKey: m,
    user: a
  };
};
var Ze2 = () => {
  const e = p();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.avatarUrl;
    },
    (t, r) => t === r
  );
};
var be = () => {
  const e = p();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.defaultRole;
    },
    (t, r) => t === r
  );
};
var et = () => {
  const e = p();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.displayName;
    },
    (t, r) => t === r
  );
};
var tt = () => {
  const e = p();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.email;
    },
    (t, r) => t === r
  );
};
var st = () => {
  const e = p();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.id;
    },
    (t, r) => t === r
  );
};
var nt = () => {
  const e = p();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.isAnonymous;
    },
    (t, r) => t === r
  );
};
var ot = () => {
  const e = p();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.locale;
    },
    (t, r) => t === r
  );
};
var rt = () => {
  const e = p();
  return useSelector(e, (t) => {
    var r;
    return t.matches("authentication.signedIn") ? ((r = t.context.user) == null ? void 0 : r.roles) || [] : [];
  });
};
function ct(e) {
  const t = p(), r = (s, o = e) => ur(t, s, o), i = async (s, o) => lr(t, s, o), d = useSelector(
    t,
    (s) => s.context.errors.registration || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), l = useSelector(
    t,
    (s) => s.matches("registration.signInEmailOTP") || s.matches("registration.verifyEmailOTP")
  ), h = useSelector(t, (s) => s.matches("authentication.signedIn")), m = useSelector(
    t,
    (s) => s.matches("registration.incomplete.needsOtp")
  ), a = useSelector(t, (s) => s.matches("registration.incomplete.failed"));
  return { signInEmailOTP: r, verifyEmailOTP: i, isLoading: l, isSuccess: h, isError: a, error: d, needsOtp: m };
}
var it = () => {
  const e = p(), t = (s, o, c) => dr(e, {
    provider: s,
    idToken: o,
    nonce: c
  }), r = useSelector(
    e,
    (s) => s.context.user,
    (s, o) => (s == null ? void 0 : s.id) === (o == null ? void 0 : o.id)
  ), i = useSelector(e, (s) => s.context.accessToken.value), d = useSelector(e, (s) => s.context.refreshToken.value), l = useSelector(
    e,
    (s) => s.context.errors.authentication || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), h = useSelector(e, (s) => s.matches({ authentication: "signedIn" })), m = useSelector(
    e,
    (s) => s.matches({ authentication: { authenticating: "idToken" } }),
    (s, o) => s === o
  ), a = useSelector(
    e,
    (s) => s.matches({ authentication: { signedOut: "failed" } }),
    (s, o) => s === o
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: a,
    isLoading: m,
    isSuccess: h,
    signInIdToken: t,
    user: r
  };
};
var at = () => {
  const e = v(), [t, r] = (0, import_react6.useState)(null), i = !t, d = !!t, [l, h] = (0, import_react6.useState)(false);
  return { linkIdToken: async ({
    provider: a,
    idToken: s,
    nonce: o
  }) => {
    h(true);
    const c = await fr(e.auth.client, {
      provider: a,
      idToken: s,
      ...o && { nonce: o }
    }), { error: E2 } = c;
    return E2 && r(E2), h(false), c;
  }, isLoading: l, isSuccess: i, isError: d, error: t };
};
var ut = () => {
  const e = p(), t = () => hr(e), r = useSelector(
    e,
    (o) => o.context.user,
    (o, c) => (o == null ? void 0 : o.id) === (c == null ? void 0 : c.id)
  ), i = useSelector(e, (o) => o.context.accessToken.value), d = useSelector(e, (o) => o.context.refreshToken.value), l = useSelector(
    e,
    (o) => o.context.errors.authentication || null,
    (o, c) => (o == null ? void 0 : o.error) === (c == null ? void 0 : c.error)
  ), h = useSelector(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), m = useSelector(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, c) => o === c
  ), a = useSelector(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, c) => o === c
  ), s = useSelector(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, c) => o === c
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: s,
    isLoading: m,
    isSuccess: h,
    needsEmailVerification: a,
    signInSecurityKey: t,
    user: r
  };
};
export {
  x as NHOST_REFRESH_TOKEN_KEY,
  we as NhostClient,
  xe as NhostProvider,
  I as NhostReactContext,
  Ae as NhostReactProvider,
  Ue as SignedIn,
  Le as SignedOut,
  ve as VanillaNhostClient,
  U as useAccessToken,
  Ce as useAddSecurityKey,
  p as useAuthInterpreter,
  Me as useAuthenticated,
  A as useAuthenticationStatus,
  Ne as useChangeEmail,
  Re as useChangePassword,
  Ke as useConfigMfa,
  Se as useDecodedAccessToken,
  Je2 as useElevateSecurityKeyEmail,
  Ve as useFileUpload,
  Pe as useFileUploadItem,
  De as useHasuraClaim,
  L as useHasuraClaims,
  at as useLinkIdToken,
  Fe2 as useMultipleFilesUpload,
  v as useNhostClient,
  _e as useProviderLink,
  qe as useResetPassword,
  He as useSendVerificationEmail,
  Qe2 as useSignInAnonymous,
  ct as useSignInEmailOTP,
  $e as useSignInEmailPassword,
  je2 as useSignInEmailPasswordless,
  Ge as useSignInEmailSecurityKey,
  it as useSignInIdToken,
  Ye2 as useSignInPAT,
  ut as useSignInSecurityKey,
  We as useSignInSmsPasswordless,
  ze2 as useSignOut,
  Be2 as useSignUpEmailPassword,
  Xe2 as useSignUpEmailSecurityKeyEmail,
  Ze2 as useUserAvatarUrl,
  Te as useUserData,
  be as useUserDefaultRole,
  et as useUserDisplayName,
  tt as useUserEmail,
  st as useUserId,
  nt as useUserIsAnonymous,
  ot as useUserLocale,
  rt as useUserRoles
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@nhost_react.js.map
